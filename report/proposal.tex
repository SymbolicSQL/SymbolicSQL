\documentclass{article}
\usepackage[pdftex]{graphicx}
\usepackage{wrapfig}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{cite}
\usepackage{xcolor}
\usepackage{inconsolata}

\newcommand\note[1]{\textcolor{red}{NOTE: #1}}

\begin{document}

\title{Symbolic Reasoning for SQL Queries}
\author{Chenglong Wang, Kaiyuan Zhang and Shumo Chu}
\date{}
\maketitle

\section*{Abstract}
SQL is a commonly used data query language for database systems. Due to the rich and complex nature of SQL queries, understanding SQL queries is not easy, and this difficulty leads to challenges in the following two scenarios: 1) checking correctness of a SQL optimization rule and 2) debugging a partially corrected SQL. Concretely, these challenges present because SQL is a highly abstract declarative language, and the semantics of a complex SQL query is hard to be inferred directly from its syntax.

To address these challenges, we consider building the formal semantics of SQL in Rosette and employing automatic verification techniques to reason about it. Particularly, we consider the applying bounded-verification techniques for SQL query semantics-equivalence checking to help verify and generate SQL rewriting rules.

\section{Introduction}

Rewriting SQL query to equivalent queries is an essential part of query
optimizer. Many commercial database systems perform aggressive SQL optimization with 
unverified rewriting rules, and chances happened that an optimization rule is not correct. 
The actual challenge is that reasoning the correctness of complicated rewriting rigorously 
requires a lot of effort and error prone.

Thus, we consider applying model checking techniques to help 1) verifying and 2) generating conditionally-correct SQL rewriting rules: i.e. 
given $Q_1$ and $Q_2$ (where $Q_2$ is generated by rewriting $Q_1$ with some rewriting rule $r$), we can use the SMT solver to verify the validity of $Q_1 \leftrightarrow Q_2$. 

As SQL query equivalence checking is generally undecidable, we plan to bound the size and arity of the
 relation for formal reasoning. Though the verification will neither be complete nor sound, we believe that being able to find counter example in bounded cases will be helpful for developers to understand these aggressive rewriting rules. 
 
Furthermore, with the equivalence checker, we can help synthesize rewriting rules that are guaranteed to be semantics preserving with embedded constraints on a database. Since developing these conditionally semantics-preserving rewriting rules is a common challenge for humans, automatically generate such rules can further exploit SQL optimization performance.

\section{Overview of This Project}
\subsection{The proposed system}
In this project, we are planning to implement a SQL query equivalence verifier
to validate the equivalence of two SQL queries under certain database schemas.
The final product of this project should be a tool that takes the database schema
definition and two SQL queries, either in the string form or in the parsed AST form, 
as the input, and determine whether these two queries are equivalent under the given
database schema. 
Furthermore, if the given SQL queries are not equivalent, the verifier will return a concrete
counter example of when the result of the two queries diverge as a guide line for the user
as a guideline to correct the mistakes in either the query design or schema design.

\subsection{A General Plan of the Project}
Here we will give a general plan of this project, which will be used as a guidance for our
project progress.
We will first try to use the similar method as Qex~\cite{veanes2010qex,veanes2009symbolic} did
to formalize the semantic of SQL queries and database schemas, this will involve both how to 
have a formal sepcification of the SQL semantic and how to encode the semantic effciently for
SMT solvers.
Then we plan to implement a symbolic execution engine for SQL queries as a prototype 
either by using symbolic engines like Rosette~\cite{torlak2014lightweight} 
or using SMT solvers like z3, and will have some unit tests on the prototype as
a proof-of-idea and a preliminary performance evaluation.

% optional
As for some optional components of the system, 
since the real world SQL queries then to be much larger in size, a naive approach of feeding everything
to the SMT solver may not work very well,
we may push further on the performance of the verifier by either having a better encoding or dig deeper
into the SMT solver to implement SQL theory modules for them.
On the other hand, we may also work on expand the user experience by make use of the synthesize functionality
of Rosette to give a possible correction of the SQL query if the given inputs are not equivalent.

\section{Related Work}

\paragraph{Symbolic SQL Reasoning} Qex~\cite{veanes2010qex,veanes2009symbolic} is a tool to generate tables based on parameterized SQL queries for database system test purpose. Concretely, Qex takes an parameterized SQL query as well as a SQL property as inputs, it will then generate a full SQL query as well as a table instance satisfying the property for database unit test. Qex has build the background theory for SQL queries and is able to translate a SQL query into SMT formulas. Our project uses the same reasoning method as Qex do, but for different application scenario, i.e. SQL semantics checking.

\paragraph{SQL semantics} There exist several previous addressing the formal SQL semantics, including Extended Three Valued Predicate Calculus~\cite{Negri:1991:FSS:111197.111212} and bag semantics~\cite{chinaei2007ordered}. We plan to formal our SQL subset using ordered bag semantics, since this is most commonly used in commercial database systems.

\paragraph{Equivalence of SQL Queries} Chirkova et al.~\cite{chirkova2009equivalence} presents a method to evaluate SQL query equivalence with presence of embedded dependencies. However, their technique addresses only a subset of SQl grammar (conjunctive queries plus aggregation), it is different from our target of equivalence checking for SQL queries with nested subqueries. 

Chakravarthy et al.~\cite{Chakravarthy:1990:LAS:78922.78924} presents a logic based approach for semantics quey optimization. Optimization rules in their systems are generated by the system so that the optimization process is semantics preserving, differently, we are able to bounded-check the whether two SQL optimization rules are equivalent or not, which is more general than their approach..

\bibliography{proposal}{}
\bibliographystyle{plain}

\end{document}
