%!TEX root=writeup.tex
\section{Introduction}

SQL or SQL-like declarative query languages are used in both relational and non-relational database management systems (RDBMS) for expressing queries. Due to the large volume of data stored in these database systems and the increasing demands of computation speed, optimizing SQL query is essential in modern data management task. 

A desired query optimizer would take a parsed representation of a SQL query as input and return as output a SQL query such that it is semantically equivalent to the previous query with better performance. A common way of query optimization nowadays is by \emph{query-rewriting}, and the rewriting rules are proved by developers so that they are guaranteed to be semantically preserving. However, coming up with useful rewriting rules is highly non-trivial and error prone, and one of the reason is that SQL has relatively rich syntax. As a result, simple and easy-to-prove rules, like writing Select-Projection-Join (SPJ) queries are less effective while useful rewriting rules like Magic Set Rewrite or aggregation rewriting rules are less common and rather hard to proof.

Thus, it is desirable to develop automatic bounded verification techniques to reason about the correctness of SQL rewriting rules. Though automatic verification techniques using SMT or SAT theories has been widely used to verify programs in general purpose languages, its application in SQL languages remains very limited. One of the key reason is that no theory of relation has been developed and as a result, unsatisfying performance restricts tasks we can perform with existing techniques: for example, Qex is only able to reason about functionality correctness but not semantics correctness.

To address the verification challenge mentioned above, instead of directly verifying using SMT solvers with theory of relations, we designed a set of denotation rules to translate SQL queries into Rosette programs and reduce the verification task of SQL queries into verification task of racket programs. With this transformation, the verification process benefits from the efficiency of Rosette and we are able to reason about many interesting SQL writing rules by proving that queries before and after transformation are semantically equivalent within a bounded size input tables.